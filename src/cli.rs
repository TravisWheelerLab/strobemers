use std::fs::File;
use std::path::Path;
use std::io::{BufReader, Write};

use anyhow::Result;
use clap::Parser;
use bio::io::fasta::Reader;


#[derive(Debug, Parser)]
#[command(about, author, version)]
pub struct CommonArgs {
    #[arg(required = true, value_name = "REF FILE", help = "References FASTA file")]
    pub references_file: String,
    #[arg(required = true, value_name = "QUERY FILE", help = "Query FAST(A/Q) file")]
    pub query_file: String,
    //#[arg(short='m', value_name = "METHOD()", help = "E.g. jaccard_similarity")] // unused
    //pub similarity_method: String,

    #[arg(short='e', value_name = "STRING", help="experiment name: output subdirectory to put CSV file")]
    pub experiment_name: String
}

fn create_csv(args_common: &CommonArgs, file_name: &String, identifier: &str) -> Result<File>{
// helper function which other csv creation methods call. This CSV file is documented in the README
// and is the main way we store similarity data.
    let file_path = Path::new(&std::env::var("CARGO_MANIFEST_DIR")?)
        .join("data")
        .join(args_common.experiment_name.clone())
        .join("_")
        .join(identifier);
    if !std::path::Path::new(&file_path).exists() {
        std::fs::create_dir(&file_path)?;
    }
    let file = File::create(&file_path.join(file_name))?;
    Ok(file)
}

pub fn create_csv_with_estimation_headers(args_common: &CommonArgs, identifier: &str) -> Result<File>{
    // only create headers for an estimation of similarity
    let mut file = create_csv(args_common, &"estimation-output.csv".to_string(), identifier)?;
    writeln!(file, "ref_name,query_name,seed_name,estimation,ref_time,query_time")?;
    Ok(file)
}

pub fn create_csv_with_estimation_and_alignment_headers(args_common: &CommonArgs, identifier: &str) -> Result<File>{
    // create headers for both estimation and alignment
    let mut file = create_csv(args_common, &"estimation-output.csv".to_string(), identifier)?;
    writeln!(file, "ref_name,query_name,seed_name,estimation,ref_time,query_time,edit_distance,edit_distance_time")?;
    Ok(file)
}


pub fn create_csv_with_alignment_headers(args_common: &CommonArgs, identifier: &str) -> Result<File>{
    // only create headers for true similarity (alignment)
    let mut file = create_csv(args_common, &"alignment-output.csv".to_string(), identifier)?;
    writeln!(file, "ref_name,query_name,seed_name,edit_distance,edit_distance_time")?;
    Ok(file)
}

/* This creates an entry for data generated by an estimation method on two strings.

Obviously, it must be compatible with create_csv_with_estimation_headers
 */
pub fn write_to_estimation_csv(file: &mut File,
    reference_id: &str,
    query_id: &str,
    seed_name: &str,
    estimation: &str,
    reference_compute_time: &str,
    query_compute_time: &str,
) -> Result<()> {
    Ok(writeln!(file, "{},{},{},{},{},{:?}",
        reference_id,
        query_id,
        seed_name,
        estimation,
        reference_compute_time,
        query_compute_time
    )?)
}


/* This creates an entry for data generated by an estimation method AND alignment
on two strings.

Obviously, it must be compatible with create_csv_with_estimation_and_alignment_headers
 */
pub fn write_to_estimation_and_alignment_csv(file: &mut File,
    reference_id: &str,
    query_id: &str,
    seed_name: &str,
    estimation: &str,
    reference_compute_time: &str,
    query_compute_time: &str,
    edit_distance: &str,
    edit_distance_time: &str
) -> Result<()> {
    Ok(writeln!(file, "{},{},{},{},{},{},{},{}",
        reference_id,
        query_id,
        seed_name,
        estimation,
        reference_compute_time,
        query_compute_time,
        edit_distance,
        edit_distance_time
    )?)
}

/* This creates an entry for data generated by alignment on two strings.

Obviously, it must be compatible with create_csv_with_alignment_headers
 */
pub fn write_to_alignment_csv(file: &mut File,
    reference_id: &str,
    query_id: &str,
    seed_name: &str,
    estimation: &str, // not alignment but too lazy to change it--this represents true edit distance
    alignment_compute_time: &str,
) -> Result<()> {
    Ok(writeln!(file, "{},{},{},{},{}",
        reference_id,
        query_id,
        seed_name,
        estimation,
        alignment_compute_time
    )?)
}

pub fn create_query_reader(args_common: &CommonArgs, identifier: &str) -> Result<Reader<BufReader<File>>> {
    // create and return a reader for the query file based on:
    // * experiment_name (directory)
    // * query_file (name of file pattern)
    // * identifier (an identifying string, documented in README).
    let project_dir = std::env::var("CARGO_MANIFEST_DIR")?;
    let query_reader = Reader::from_file(
        Path::new(&project_dir)
            .join("data")
            .join(&args_common.experiment_name)
            .join(&args_common.query_file)
            .join(identifier)
        )?;
    Ok(query_reader)
}

pub fn create_reference_reader(args_common: &CommonArgs, identifier: &str) -> Result<Reader<BufReader<File>>> {
    let project_dir = std::env::var("CARGO_MANIFEST_DIR")?;
    let query_reader = Reader::from_file(
        Path::new(&project_dir)
            .join("data")
            .join(&args_common.experiment_name)
            .join(&args_common.references_file)
            .join(identifier)
        )?;
    Ok(query_reader)
}

pub fn print_update(i: usize) {
    print!("\r comparisons done: {:?}", i);
    std::io::stdout().flush().unwrap();
}